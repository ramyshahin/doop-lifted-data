ABORT
CASCADE
NULLIFY
ForeignKeyDeleteAction.
<<\\"Lock Table \\">>
NULL_LSN without KnownDeleted
0000000000000000
0x
SET
BOTH
SET_RANGE
BOTH_RANGE
SearchMode.
Transaction
Lock
Transaction
\\\">
</ref>
<lsn/>
<key/>
<target/>
<knownDeleted val=\\\"
\\\"/>
<pendingDeleted val=\\\"
\\\"/>
\\\"/>
<<\\"\\">>
<<\\"usage: \\">>
remaining=
NEXT
PREV
NEXT_DUP
PREV_DUP
NEXT_NODUP
PREV_NODUP
++++++++++ begin lock table dump ++++++++++
++++++++++ end lock table dump ++++++++++
-f requires an argument
-h requires an argument
: waited for lock
-s requires an argument
<<\\"-c: \\">>
lsn=
-c requires an argument
\n
-h is a required argument
-v requires -f
<<\\"DbLoad.load of \\">>
<<\\"Load start: \\">>
Must supply a database name if -l not supplied.
<<\\"DbLoad.load of \\">>
<<\\"Load end: \\">>
<<\\"Transfer, lock \\">>
<<\\"Invalid header parameter: \\">>
<<\\"Transfer, lock \\">>
<<\\"Version \\">>
\'
primaryDatabase
Can\'t use as primary:
<<\\"Duplicates must not be allowed for a primary database: \\">>
Primary and secondary databases must be in the same environment
secConfig.getKeyCreator() and getMultiKeyCreator() may not both be non-null
secConfig and getKeyCreator()/getMultiKeyCreator() may be null only if the primary database is read-only
secConfig.getForeignKeyNullifier() and getForeignMultiKeyNullifier() may not both be non-null
ForeignKeyNullifier or ForeignMultiKeyNullifier must be non-null when ForeignKeyDeleteAction is NULLIFY
ForeignKeyNullifier may not be used with SecondaryMultiKeyCreator -- use ForeignMultiKeyNullifier instead
<<\\"No data to match key \\">>
<<\\"Duplicates must not be allowed for a foreign key  database: \\">>
<<\\"Key exists: \\">>
<<\\"loaded \\">>
No \\\"DATA=END\\\"
<<\\"Secondary is already associated with a different primary: \\">>
----\n
SecondaryDatabase open
Corrupted file
Corrupted file
\n
<<\\" waits for \\">>
<<\\" nothing\\">>
<<\\" node \\">>
\n
<<\\"Transaction \\">>
key
\n
Can\'t call SecondaryDatabase.delete:
SecondaryDatabase.delete
<<\\"environmentImpl is null for target db \\">>
key
pKey
data
Can\'t call SecondaryDatabase.get:
SecondaryDatabase.get
key
pKey
data
Can\'t call SecondaryDatabase.getSearchBoth:
SecondaryDatabase.getSearchBoth
initialized
open
closed
invalid
<<\\"Can\'t go from environment state \\">>
Cleaner.addToQueue should never be called.
\n
<<\\"CleanerRun \\">>
Cleaner
doClean
<<\\"\\">>
Btree
<<\\"CleanerRun \\">>
Duplicate
<<\\"CleanerRun \\">>
The following DatabaseConfig parameters for the\ncached Database do not match the parameters for the\nrequested Database:\n
<<\\" Transactional\n\\">>
<<\\" Read-Only\n\\">>
<<\\" Sorted Duplicates\n\\">>
<<\\" Btree Comparator\n\\">>
<<\\" Duplicate Comparator\n\\">>
Non-blocking lock was denied.
\\"RootSplit:\\"
\\"DupRootSplit:\\"
\\"Mut:\\"
\\"Ins:\\"
\\"InsD:\\"
<<\\"Secondary \\">>
RootLatch
CleanLN:
CleanLN:
CleanLN:
CleanLN:
CleanLN:
<<\\"Secondary \\">>
<<\\"Could not insert secondary key in \\">>
<<\\"\\">>
CleanLN:
CleanLN:
<<\\"Secondary \\">>
Nested transactions are not supported yet.
CleanIN:
CleanIN:
CleanIN:
<<\\"XA Transaction \\">>
<<\\"Secondary \\">>
Operation not allowed on a secondary
\\\"/>
je.disable.java5.latches
java.util.concurrent.locks.ReentrantLock
java.util.concurrent.locks.ReentrantReadWriteLock
LatchImpl
\\"usage: java <utility> [options...]\\"
\\"com.sleepycat.je.util.\\"
Missing utility name
com.sleepycat.je.util.
NEW
WAIT_NEW
PROMOTION
WAIT_PROMOTION
EXISTING
DENIED
WAIT_RESTART
NONE_NEEDED
\\"<dbin>\\"
\\"</dbin>\\"
usage: java <utility> [options...]
getFirstNode passed null root
getLastNode passed null root
Bad value for timeout:
Bad value for timeout:
getParentNode passed null
<dbin>
</dbin>
<dupkey>
<<\\"\\">>
</dupkey>
DBIN
allowCreate=
This statement would have triggered an Exception: virtualinvoke searchResult#1.<com.sleepycat.je.tree.IN: void releaseLatchIfOwner()>()
<<\\"A per-thread transaction was created in \\">>
<offsets size=\\\"
\\\">
0x
</offsets>
<offsets size=\\\"0\\\"/>
\\"DupRootRecover:\\"
\\"LNRedo:\\"
subtree did not have a BIN for leaf
\\"LNUndo\\"
\\"INRecover:\\"
\\"RootRecover:\\"
\\"INDelReplay:\\"
\\"INDupDelReplay:\\"
\\"RootDelete:\\"
RootSplit:
Recovery underway, found end of log
<<\\"Recovery checkpoint search, \\">>
Recovery w/no files.
searchSubTree passed key and left/right search
<<\\"There are \\">>
recovery
RecoveryManager
recover
Couldn\'t recover
<<\\"Couldn\'t recover: \\">>
<<\\"Recovery finished: \\">>
<<\\"Invalid value of searchType: \\">>
<<\\"Recovery finished: \\">>
lastUsed=
<<HASH:-870535562>>
foreignKeyDeleteAction
<<\\"prepare() has already been called for Transaction \\">>
<<\\"Transaction \\">>
The SecondaryConfig argument is null.
The following SecondaryConfig parameters for the\ncached Database do not match the parameters for the\nrequested Database:\n
<<\\"Transaction \\">>
<<\\" SecondaryKeyCreator\n\\">>
<<\\" SecondaryMultiKeyCreator\n\\">>
<<\\" ForeignKeyDelete\n\\">>
<<\\" ForeignKeyDeleteAction\n\\">>
<<\\" ForeignKeyNullifier\n\\">>
<<\\" ForeignMultiKeyNullifier\n\\">>
<<\\" ImmutableSecondaryKey\n\\">>
DEFAULT
READ_UNCOMMITTED
READ_COMMITTED
RMW
LockMode.
<<\\"Commit of transaction \\">>
Txn
commit
<<\\"Failed while attempting to commit transaction \\">>
<<\\"Failed while attempting to commit transaction \\">>
\\\">
</INDeleteEntry>
<<\\"Abort:id = \\">>
Unexpected interrupt while waiting for fsync
<<\\"Transaction \\">>
Txn undo for node=
readMapIns
idKey=
readNonMapIns
.bad
<<\\"Found unfinished prepare record: id: \\">>
undoLNs
<<\\"Couldn\'t find lock for Node \\">>
<<\\"\\">>
<<\\"Can\'t find \\">>
redoLns
<<\\"Can\'t find \\">>
\\\">
<ckptStart>
</ckptStart>
<root>
</root>
<firstActive>
</firstActive>
</CkptEnd>
<<\\" lsnFromLog:\\">>
RecoveryManager
replaceOrInsert
lsnFromLog=
Trace list:
This statement would have triggered an Exception: virtualinvoke dupRoot#4.<com.sleepycat.je.tree.DIN: void releaseLatch()>()
neither LN or DIN found in BIN
<<\\"Transaction \\">>
<<\\"Transaction \\">>
<txn id=\\\"
\\\">
</txn>
lsnFromLog=
RootRecover:
RootRecover:
DupRootSplit:
\\"<ln>\\"
\\"</ln>\\"
DupRootRecover:
DupRootRecover:
All nodes should have been loaded
INRecover:
INRecover:
INRecover:
allowDuplicates passed to insert but database doesn\'t have allow duplicates set.
<ln>
</ln>
<data>
</data>
LNRedo:
<<\\"SubtreeRemoval: subtreeRoot = \\">>
LNRedo:
<data>
</data>
LNRedo:
<root>
</root>
<tree>
<in/>
</tree>
<DatabaseEntry
>
<<\\"IN \\">>
<<\\"IN \\">>
<<\\"IN \\">>
LNUndo
LNUndo
Mut:
<<\\" existingLn=\\">>
<<\\" newLn=\\">>
<<\\" newLnLsn=\\">>
<<\\" dupCountLN=\\">>
<<\\" dupRootLsn=\\">>
<<\\" rootdin=\\">>
<<\\" ddinLsn=\\">>
<<\\" dbin=\\">>
<<\\" dbinLsn=\\">>
<<\\" bin=\\">>
Ins:
<<\\" bin=\\">>
<<\\" ln=\\">>
<<\\" lnLsn=\\">>
<<\\" index=\\">>
InsD:
<<\\" dbin=\\">>
<<\\" bin=\\">>
<<\\" ln=\\">>
<<\\" lnLsn=\\">>
<<\\"Logged item entrySize= \\">>
<<\\"Recovery Pass \\">>
<<\\"Recovery Pass \\">>
<<\\" node=\\">>
<<\\" lsn=\\">>
<<\\" found=\\">>
<<\\" replaced=\\">>
<<\\" inserted=\\">>
<<\\" replacedLsn=\\">>
<<\\" abortLsn=\\">>
<LockInfo locker=\\\"
\\\" type=\\\"
\\\"/>
<<\\" lock taken at: \\">>
<<\\"usage: \\">>
INDupDelReplay:
INDelReplay:
<<\\"last LSN = \\">>
RecoveryManager
last LSN=
RootDelete:
TxnPrepare
-h requires an argument
-h is a required argument
\\\">
>
File 0x
<<\\"  File    Size (KB)  % Used\n--------  ---------  ------\\">>
<<\\"Read non-valid log entry type: \\">>
Channel closed, may be due to thread interrupt
Channel closed, may be due to thread interrupt
\\"daemon\\"
\\"manual\\"
\\"critical\\"
Log statistics:
type
total
provisional
total
min
max
avg
entries
<<\\"\\">>
count
count
bytes
bytes
bytes
bytes
as % of log
\\\"/>
Evictor.addToQueue should never be called.
activeTxns=[
]\n
daemon
key/data
<<\\"\\">>
<<\\"\\">>
<<\\"\\">>
critical
<<\\"\\">>
<<\\"\\">>
(
<<\\"\nTotal bytes in portion of log read: \\">>
<DbPrintLog>
<<\\"Total number of entries: \\">>
</DbPrintLog>
<<\\" \\">>
.
Evictor: pass=
\nPer checkpoint interval info:
lnTxn
ln
Evictor: pass=
mapLNTxn
mapLN
\n
Evictor: pass=
<<\\"Usage: \\">>
end-end
<<\\"latches held = \\">>
end-start
numBottomInternalNodes=
start-end
\n
<<\\" -h  <envHomeDir>\\">>
<<\\" -e  <end file number, in hex>\\">>
numInternalNodes=
<<\\" -k  <binary|text> (format for dumping the key)\\">>
\n
<<\\" -s  <start file number, in hex>\\">>
<<\\" -tx <targetted txn ids, comma separated>\\">>
numDuplicateInternalNodes=
maxLNReplay
<<\\" -ty <targetted entry types, comma separated>\\">>
<<\\" -S  show Summary of log entries\\">>
\n
ckptEnd
<<\\" -q  if specified, concise version is printed\\">>
<<\\"     Default is verbose version.)\\">>
All arguments are optional
numDuplicateBottomInternalNodes=
\n
\n
\n
\n
\n
\n
\\"    Cache Size      Btree Size  Description\n--------------  --------------  -----------\\"
<<\\"DatabaseEntry \\">>
<<\\"Data field for DatabaseEntry \\">>
A partial key DatabaseEntry is not allowed
\\"<fileSummaryLN>\\"
\\"</fileSummaryLN>\\"
UTF-8
<fileSummaryLN>
</fileSummaryLN>
Txnl access to UP db not allowed
No value after -records
No value after -key
No value after -data
\\\"/>
No value after -nodemax
No value after -density
daemon
<<\\" IN type=\\">>
No value after -overhead
No value after -measure
<<\\"Database \\">>
.
<<\\"Unknown arg: \\">>
.
<<\\" lastCkpt=\\">>
-records not specified
-key not specified
<<\\" lastCkpt=\\">>
<<\\" lastCkpt=\\">>
<<\\" lastCkpt=\\">>
<<\\"usage:\njava \\">>
<<\\" lastCkpt=\\">>
Inputs: records=
<<\\"    Cache Size      Btree Size  Description\n--------------  --------------  -----------\\">>
Minimum, internal nodes only
Maximum, internal nodes only
Minimum, internal nodes and leaf nodes
Maximum, internal nodes and leaf nodes
\nTo get leaf node sizing specify -data
<<\\"\nBtree levels: \\">>
<<\\"Directory is not empty: \\">>
<<\\"\nMeasuring with cache size: \\">>
Stats for internal and leaf nodes (after insert)
<<\\"\nPreloading with cache size: \\">>
Stats for internal nodes only (after preload)
<<\\"During close: \\">>
<<\\"During close: \\">>
foo
*** Key doesn\'t fit value=
READ
WRITE
RANGE_READ
RANGE_WRITE
RANGE_INSERT
NONE
Random key already exists -- retrying
RESTART
<<\\"*** \\">>
<<\\"*** Ran out of cache memory at record \\">>
.
true
false
false
1000
<<\\"Files cleaned: \\">>
.
<<\\"\nrecovery time = \\">>
<<\\"action time = \\">>
<<\\"\nrecovery time = \\">>
<<\\"action time = \\">>
<<\\"\nrecovery time = \\">>
CacheSize=
<<\\"action time = \\">>
*** All records did not fit in the cache ***
txnId=
cleanedCount=
<<\\"Remove of \\">>
Preload starting
<<\\"Preloaded \\">>
evict time=
<<\\"Usage: \n \\">>
<<\\"  -h <environment home> \\">>
<<\\"  -a <clean|compress|evict|checkpoint|removedb>\\">>
<<\\"  -ro (read-only - defaults to read-write)\\">>
<<\\"  -s <dbName> (for preloading of evict or db remove)\\">>
\\"<node>\\"
\\"</node>\\"
.
matchLNByNodeId called on non DIN/DBIN
\\"<bin>\\"
\\"</bin>\\"
<<\\"Usage: \\">>
<<\\"txnId = \\">>
<<\\"                 -h <environment home>\\">>
(optional)
<<\\"                 -f <file number, in hex>\\">>
<<\\"                 -o <offset, in hex>\\">>
Log file is truncated at position starting at and inclusive of the offset. Beware, not  for general purpose use yet!
<node>
</node>
r
rw
<
Already closed
<node>
<<\\"Wrong filenum in header for file \\">>
</node>
fsyncLatch
key
<<\\"JoinCursor.getNext(key): \\">>
<<\\"Expected log version 3 or earlier but found \\">>
key
data
<FileHeader num=\\\"0x
<<\\"JoinCursor.getNext(key,data): \\">>
\\\" lastEntryInPrevFileOffset=\\\"0x
\\\" logVersion=\\\"0x
\\\"/>
\\"CleanIN:\\"
\\"CleanLN:\\"
\\"CleanMigrateLN:\\"
\\"CleanPendingLN:\\"
Secondary corrupt
nodeId=
<<\\"null buffer given to checksum validation, probably  result of 0\'s in log file. \\">>
\\".jdb\\"
\\".cif\\"
\\".del\\"
\\".bad\\"
\\".lck\\"
.del
.jdb
.jdb
.del
<<\\"Location \\">>
<<\\"Location \\">>
<<\\"Both \\">>
<<\\"Environment home \\">>
.jdb
<<\\"\\">>
BIN must be latched before evicting LNs
.jdb
<<\\"\\">>
.
<<\\"Couldn\'t rename \\">>
<bin>
</bin>
BIN
<<\\"Cleaner has \\">>
<<\\"Couldn\'t delete \\">>
.del
Cleaner deleted file 0x
Log file 0x
deleted
renamed
Cleaner
deleteSafeToDeleteFiles
<<\\"Couldn\'t open file \\">>
<summary totalCount=\\\"
\\\" totalSize=\\\"
\\\" totalINCount=\\\"
\\\" totalINSize=\\\"
<<\\"Couldn\'t open file \\">>
\\\" totalLNCount=\\\"
\\\" totalLNSize=\\\"
\\\" obsoleteINCount=\\\"
\\\" obsoleteLNCount=\\\"
\\\"/>
CleanPendingLN:
SUCCESS
KEYEXIST
KEYEMPTY
NOTFOUND
CleanPendingLN:
Channel closed, may be due to thread interrupt
OperationStatus.
<<\\"IOException caught: \\">>
CleanPendingLN:
<<\\"File \\">>
CleanPendingLN:
CleanPendingLN:
CleanPendingLN:
CleanPendingLN:
\\\">
>
FileManager would overwrite non-empty file 0x
generated for testing
File closed, may be due to thread interrupt
generated for testing
CleanMigrateLN:
\\\"/>
CleanMigrateLN:
CleanMigrateLN:
<<\\"Shutting down \\">>
Usage: EnvironmentParams <samplePropertyFile>
Exiting
####################################################\n# Example Berkeley DB, Java Edition property file\n# Each parameter is set to its default value\n####################################################\n\n
Continuing
#
<<\\"usage: \\">>
DbState.
\\"INCompress:\\"
<<\\"Exit status = \\">>
<<\\"Exit status = \\">>
<<\\"Exit status = \\">>
\\\"/>
je.lck
rw
INCompressor.addToQueue should never be called.
<<\\"A je.lckfile exists in \\">>
shared
single writer
<<\\"The Environment directory \\">>
-h requires an argument
-s requires an argument
-v requires a positive argument
-v requires an argument
-h is a required argument
-s is a required argument
Write after RunRecoveryException
<<\\"DbVerify.verify of \\">>
Randomly generated for testing
Checking obsolete offsets ...
<<\\"DbVerify.verify of \\">>
<<\\"DbVerify.verify of \\">>
\\";\\"
<<\\"usage: \\">>
<<\\" A configuration parameter name can\'t be null or 0 length\\">>
<<\\"InCompress.doCompress called, queue size: \\">>
<<\\"\\">>
<<\\"\\">>
-f requires an argument
-h requires an argument
-d requires an argument
-s requires an argument
-h is a required argument
Must supply a database name if -l not supplied.
true
false
<<\\"\\">>
<<\\"\\">>
<<\\"DbDump.dump of \\">>
DATA=END
<<\\"DbDump.dump of \\">>
VERSION=3
format=print
format=bytevalue
type=btree
dupsort=
1
0
HEADER=END
\\"Delete\\"
\\"Mod:\\"
<<\\"CleanAddPendingDB \\">>
<<\\" node=\\">>
<<\\" logLsn=\\">>
<<\\"Attempt to \\">>
<<\\"failed adding in \\">>
<<\\"Error Key \\">>
UNKNOWN
<<\\"Error Data \\">>
UNKNOWN
\n
<<\\"maxBytes parameter to Database.preload() was specified as \\">>
<database id=\\\"
\\\"
<<\\" btc=\\\"\\">>
\\\"
<<\\" dupc=\\\"\\">>
\\\"
/>
Btree
Duplicate
couldn\'t instantiate class comparator
<database>
\\\"/>
<btcf name=\\\"
\\\"/>
<dupcf name=\\\"
\\\"/>
Delete
</database>
size=
db=
<<\\"\\">>
<<\\"Exception while trying to load \\">>
<<\\"Exception while trying to load \\">>
TxnAbort
\\"je.info\\"
<
<<\\" exists = \\\"\\">>
\\\">
\\\"/>
<<\\"Problem parsing parameter \\">>
<Dbg time=\\\"
\\\">
<msg val=\\\"
\\\"/>
</Dbg>
<TreeLocation bin=\\\"
null
\\\" index=\\\"
\\\" lnKey=\\\"
\\\" childLsn=\\\"
\\\">
\\\">
</INDupDeleteEntry>
putNoDupData() called, but database is not configured for duplicate data.
A checksum error was found in the log.
<<\\"Corruption begins at LSN:\n   \\">>
<<\\"Last known good record before corruption is at LSN:\n   \\">>
<<\\"Next known good record after corruption is at LSN:\n   \\">>
<<\\"Cannot read backward over cleaned file from \\">>
<<\\"FileReader read invalid log entry type: \\">>
Can\'t replace a duplicate with different data.
Mod:
<<\\"Problem in fillReadBuffer, readBufferFileNum = \\">>
SUCCESS
FILLED_CACHE
EXCEEDED_TIME
PreloadStatus.
<<\\"Dup Offset \\">>
copy.remaining=
\\\" isProvisional=\\\"true
\\\" prev=\\\"0x
\\\">
</entry>
\\"je.properties\\"
envHome
<<\\"locker \\">>
<<\\"locker \\">>
je.properties
<<\\" Owners:\\">>
<<\\" (none)\\">>
<<\\" Waiters:\\">>
<<\\" (none)\\">>
<<\\"An error occurred when reading \\">>
LN_TX
LN
MapLN_TX
<<\\"There \\">>
MapLN
is 1 open Database in the Environment.\n
<<\\"are \\">>
NameLN_TX
<<\\" open Database in the Environment.\n\\">>
NameLN
Closing the following databases:\n
DelDupLN_TX
<<\\" \\">>
DelDupLN
DupCountLN_TX
DupCountLN
<<\\"There \\">>
is 1 existing transaction opened against
<<\\" the Environment.\n\\">>
FileSummaryLN
<<\\"are \\">>
IN
<<\\" existing transactions opened against\\">>
<<\\" the Environment.\n\\">>
BIN
Aborting open transactions ...\n
DIN
DBIN
Root
Commit
Abort
CkptStart
CkptEnd
INDelete
BINDelta
DupBINDelta
Trace
FileHeader
INDupDelete
Prepare
databaseName
Environment.open:  name=
<<\\"Database \\">>
)
<<\\"Database \\">>
<<\\"<LATCH \\">>
<<\\"] \\">>
]
<<\\" [waiters: \\">>
<<\\" \\">>
]
>
<<\\"Attempted to open Database \\">>
<<\\"Attempted to open Database \\">>
databaseName
\\\" gTxnId=\\\"
null
\\\" bqual=\\\"
null
\\\"/>
databaseName
newName
databaseName
<<\\"\\">>
Transactions can not be used in a non-transactional environment
Only one may be specified: SerializableIsolation, ReadCommitted or ReadUncommitted
\\\"/>
BIN cursorSet is inconsistent.
Cursor Not Initialized.
Cursor has been closed.
<<\\"Unknown cursor status: \\">>
api
sync
mutableConfig
<Transaction id=\\\"
\\\"
<<\\" name=\\\"\\">>
\\\"
>
CURSOR_NOT_INITIALIZED
CURSOR_INITIALIZED
CURSOR_CLOSED
UNKNOWN (
<<\\"Transaction \\">>
\\\"
\\\"
\\\"
\\"<nameLN>\\"
>\n
\\"</nameLN>\\"
<<\\"\\">>
<<\\"\\">>
\n</Cursor>
<nameLN>
</nameLN>
<<\\" bin=\\">>
Attempt to use non-open Environment object().
\\\">
<<\\" ln=\\">>
<<\\" lnIdx=\\">>
\\\">
<<\\" oldLnLsn=\\">>
<<\\" newLnLsn=\\">>
OPEN
CLOSED
INVALID
DatabaseConfig.setReadOnly() must be set to false when creating a Database
delete
<<\\"SecondaryCursor.delete: \\">>
<<\\"You can\'t open a Database with a duplicatesAllowed configuration of \\">>
<<\\"You can\'t open a Database with a transactional configuration of \\">>
<<\\"SecondaryCursor.getCurrent: \\">>
Can\'t close Database:
<<\\"Database.close: \\">>
There are open cursors against the database.\n
<<\\"SecondaryCursor.getFirst: \\">>
They will be closed.\n
key
Can\'t call Database.openSequence:
openSequence
Database.openSequence
<<\\"SecondaryCursor.getLast: \\">>
Can\'t open a cursor
Only one may be specified: ReadCommitted or ReadUncommitted
<<\\"SecondaryCursor.getNext: \\">>
Database.openCursor
key
Can\'t call Database.delete:
delete
<<\\"SecondaryCursor.getNextDup: \\">>
Database.delete
<<\\"SecondaryCursor.getNextNoDup: \\">>
<<\\"SecondaryCursor.getPrev: \\">>
<<\\"Error in \\">>
,-
,
-
key
data
<<\\"SecondaryCursor.getPrevDup: \\">>
Can\'t call Database.get:
Database.get
<<\\"SecondaryCursor.getPrevNoDup: \\">>
key
data
Can\'t call Database.getSearchBoth:
Database.getSearchBoth
key
pKey
data
<<\\"SecondaryCursor.getSearchKey: \\">>
key
data
Can\'t call Database.put
put
Database.put
key
pKey
data
<<\\"SecondaryCursor.getSearchKeyRange: \\">>
key
data
Can\'t call Database.putNoOverWrite
putNoOverwrite
Database.putNoOverwrite
key
key
pKey
data
data
Can\'t call Database.putNoDupData
<<\\"SecondaryCursor.getSearchBoth: \\">>
putNoDupData
Database.putNoDupData
key
pKey
data
<<\\"SecondaryCursor.getSearchBothRange: \\">>
Cannot write file summary in a read-only environment
.jdb
Can\'t call Database.join
cursors
At least one cursor is required.
All cursors must use the same transaction.
All cursors must use the same environment.
All cursors must use the same transaction.
Can\'t call Database.truncate
truncate
Database.truncate: txnId=
null
couldn\'t find database - truncate
truncate
Can\'t call Database.preload
preload
Can\'t call Database.preload
preload
Can\'t call Database.preload
preload
key
pKey
data
Can\'t call Database.stat
\\"<mapLN>\\"
\\"</mapLN>\\"
stat
Can\'t call Database.verify
verify
<mapLN>
</mapLN>
\\\">
_jeUtilization
_jeUtilization
Cleaner duplicate key sequence file=0x
nGets=
<<\\"Database is Read Only: \\">>
<<\\"lsn \\">>
\\"LatchImpl\\"
<<\\" name=\\">>
LatchImpl
waitTarget.active but not owner
<<\\"No transaction found for \\">>
<DbLsn val=\\\"0x
0x
<<\\"No transaction found for \\">>
.
.
.
.
<<\\" (\\">>
)
<<\\"No transaction found for \\">>
.
\\"<din>\\"
\\"</din>\\"
<<\\"Environment invalid because of previous exception: \\">>
Sequences not supported in databases configured for duplicates
Minimum sequence value must be less than the maximum
Initial sequence value is out of range
The cache size is larger than the sequence range
ExclusiveCreate=true and the sequence record already exists.
Sequence record removed during openSequence.
AllowCreate=false and the sequence record does not exist.
<din>
</din>
<dupkey>
<<\\"\\">>
</dupkey>
<dupCountLN/>
DIN
<<\\"Obsolete lsns contains valid lsn \\">>
<<\\"Tree contains obsolete lsn \\">>
Sequence delta must be greater than zero
Lsn mismatch
Sequence delta is larger than the range
<<\\"Sequence overflow \\">>
Sequence.get value=
TxnCommit
\\"<dupCountLN>\\"
\\"</dupCountLN>\\"
<dupCountLN>
</dupCountLN>
The sequence record has been deleted while it is open.
\\\"/>
non LogEntryType passed to LogEntryType.compare
exactParentFound=
null
,
,
\\"_jeIdMap\\"
\\"_jeNameMap\\"
\\"_jeUtilization\\"
_jeIdMap
_jeNameMap
_jeUtilization
_jeIdMap
_jeNameMap
_jeIdMap
_jeNameMap
<<\\"Cache percent is not a valid integer: \\">>
<<\\"can\'t find database \\">>
<<\\"Attempted to \\">>
<<\\"Can\'t \\">>
rename
remove
truncate
<<\\"Database \\">>
<<\\"Can\'t truncate database \\">>
<key v=\\\"
<null>
<null>
<<\\"\\">>
\\\"/>
key=
\\"!\\\"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\"
!\\\"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~
false
true
SEVERE
false
<<\\"java { \\">>
_jeIdMap
_jeNameMap
UTF-8
UTF-8
<dbtree lastId = \\\"
\\\">
<idDb>
</idDb><nameDb>
</nameDb>
</dbtree>
<dbTree lastDbId =\\\"
\\\">
</dbtree>
\\"<in>\\"
\\"</in>\\"
\\"Split:\\"
\\"Delete:\\"
<<\\"usage: \\">>
<<\\"usage: \\">>
-h requires an argument
-s requires an argument
-v requires a positive argument
-v requires an argument
-h is a required argument
-s is a required argument
<<\\"DbStat.stats of \\">>
<<\\"DbStat.stats of \\">>
NULL_LSN without KnownDeleted
<<\\"fetchTarget of \\">>
null lsn
<<\\"-Warning: Out of sync. Should be \\">>
<knownDeleted val=\\\"
true
false
\\\"/>
<<\\"Node \\">>
A Transaction cannot be used because the environment was opened non-transactionally
A Transaction cannot be used because the database was opened non-transactionally
A Transaction cannot be used because the database was opened non-transactionally
A Transaction cannot be used because the database was opened non-transactionally
idkey is null
<dbId id=\\\"
\\\"/>
\\"  File    Size (KB)  % Used\n--------  ---------  ------\\"
<<\\"IN \\">>
<<\\"IN \\">>
<<\\" TOTALS \\">>
<<\\"  \\">>
<<\\"     \\">>
<<\\"Found non-deletable IN \\">>
\\"                                                                                                                                \\"
<<\\"                                                                                                                                \\">>
<<\\" \\">>
null
<<\\"Invalid value of searchType: \\">>
<<\\"Pass 1: \\">>
<<\\"Pass 2: \\">>
<<\\"End: \\">>
<<\\"processing file \\">>
<<\\".jdb  \\">>
<<\\"Already name mapped for dbId: \\">>
<<\\"Already saw dupSort entry for dbId: \\">>
<isRoot val=\\\"
\\\"/>
<level val=\\\"
\\\"/>
<entries numEntries=\\\"
\\\" length=\\\"
\\\" baseFileNumber=\\\"
\\\">
\\\">
</ref>
</entries>
db
<in>
</in>
DATA=END
<idkey>
<<\\"\\">>
</idkey>
\\\"/>
\\\"/>
<level val=\\\"
\\\"/>
\\\"/>
<entries nEntries=\\\"
\\\">
<entry id=\\\"
<lsn/>
<key/>
<target/>
\\\"/>
</entry>
</entries>
<knownDeleted val=\\\"
\\\"/>
<pendingDeleted val=\\\"
\\\"/>
IN
Split:
<<\\" parent=\\">>
<<\\" child=\\">>
<<\\" newSibling=\\">>
<<\\" parentLsn = \\">>
<<\\" childLsn = \\">>
<<\\" newSiblingLsn = \\">>
<<\\" splitIdx=\\">>
<<\\" idKeyIdx=\\">>
<<\\" childIdx=\\">>
Delete:
<<\\" index=\\">>
<<\\"Not Exception or Error: \\">>
<<\\"<LatchWaiter: \\">>
<lastFullLsn>
</lastFullLsn>
\\\"/>
----- Event Dump -----
\\"je.disable.java.adler32\\"
MapTreeRoot
Can\'t set \'je.env.isNoLocking\' and \'je.env.isTransactional\';
<<\\"Enviroment creation isn\'t allowed,  but there is no pre-existing  environment in \\">>
Recovery Info
TriggerLatch
<<\\" lastUsed=\\">>
<<\\" nextAvail=\\">>
<<\\" ckptStart=\\">>
<<\\" firstActive=\\">>
<<\\" ckptEnd=\\">>
<<\\" useRoot=\\">>
>
Evictor
Checkpointer
INCompressor
Cleaner
Attempt to use a Environment that has been closed.
<<\\"Close of environment \\">>
close
<<\\"\nException shutting down daemon threads: \\">>
\n
<<\\"Env \\">>
<<\\"\nException clearing file manager: \\">>
\n
<<\\"\nException clearing file manager: \\">>
\n
<<\\"Problem: \\">>
<<\\"Problem: \\">>
Some latches held at env close.
Lock, transaction, or latch left behind at environment close
File Flip
manual
beginTransaction called,  but Environment was not opened with transactional cpabilities
\\"sun.arch.data.model\\"
\\"je.forceJVMArch\\"
1.4 based 64 bit JVM not supported
Mac OS X
<<\\"Cursor.count: \\">>
delete
<<\\"Cursor.delete: \\">>
key
data
put
<<\\"Cursor.put: \\">>
key
data
putNoOverwrite
<<\\"Cursor.putNoOverwrite: \\">>
key
data
putNoDupData
<<\\"Cursor.putNoDupData: \\">>
data
putCurrent
<<\\"Cursor.putCurrent: \\">>
<<\\"Cursor.getCurrent: \\">>
<<\\"Cursor.getFirst: \\">>
<<\\"Cursor.getLast: \\">>
<<\\"Cursor.getNext: \\">>
<<\\"Cursor.getNextDup: \\">>
<<\\"Cursor.getNextNoDup: \\">>
<<\\"Cursor.getPrev: \\">>
<<\\"Cursor.getPrevDup: \\">>
<<\\"Cursor.getPrevNoDup: \\">>
key
data
<<\\"Cursor.getSearchKey: \\">>
key
data
<<\\"Cursor.getSearchKeyRange: \\">>
<<\\"Cursor.getSearchBoth: \\">>
<<\\"Cursor.getSearchBothRange: \\">>
put passed a null DatabaseEntry arg
put passed a null DatabaseEntry arg
unknown PutMode
This statement would have triggered an Exception: $stack45 = result#4.<com.sleepycat.je.dbi.CursorImpl$KeyChangeStatus: com.sleepycat.je.OperationStatus status>
unknown GetMode
<<\\"A transaction was not supplied when opening this cursor: \\">>
key
data
key
data
