<Vertex: java.util.LinkedList getNeighborsObj()>	<Vertex: java.util.LinkedList getNeighborsObj()>	@GN_OnlyNeighbors
<Graph$EdgeIter1: void <init>(Graph)>	<Graph$EdgeIter1: void <init>(Graph)>
<<\\" comp# \\">>	<<\\" comp# \\">>	@Connected
<Graph: Graph kruskal()>	<Graph: Graph kruskal()>
<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>	<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>
<java.util.LinkedList: java.lang.Object remove(int)>	<java.util.LinkedList: java.lang.Object remove(int)>
<Graph: void stopBenchmark()>	<Graph: void stopBenchmark()>	@Benchmark
<Edge: Vertex getOtherVertex(Vertex)>	<Edge: Vertex getOtherVertex(Vertex)>	@EdgeObjects
<WorkSpace: void init_vertex(Vertex)>	<WorkSpace: void init_vertex(Vertex)>	@SearchBase
<java.util.Map: java.lang.Object get(java.lang.Object)>	<java.util.Map: java.lang.Object get(java.lang.Object)>
<java.util.Iterator: boolean hasNext()>	<java.util.Iterator: boolean hasNext()>
<Neighbor: int getWeight()>	<Neighbor: int getWeight()>	@Weighted /\ GN_OnlyNeighbors
<EdgeIfc: void setWeight(int)>	<EdgeIfc: void setWeight(int)>
<java.lang.Integer: int parseInt(java.lang.String,int)>	<java.lang.Integer: int parseInt(java.lang.String,int)>
<Edge: void adjustAdorns(EdgeIfc)>	<Edge: void adjustAdorns(EdgeIfc)>	@EdgeObjects
<EdgeIter: boolean hasNext()>	<EdgeIter: boolean hasNext()>
<java.lang.StringBuilder: java.lang.StringBuilder append(boolean)>	<java.lang.StringBuilder: java.lang.StringBuilder append(boolean)>
<Graph: void runBenchmark(java.lang.String)>	<Graph: void runBenchmark(java.lang.String)>	@Benchmark
<Graph$EdgeIter1: void <init>(Graph,Graph$EdgeIter1)>	<Graph$EdgeIter1: void <init>(Graph,Graph$EdgeIter1)>
<Graph: void sortVertices(java.util.Comparator)>	<Graph: void sortVertices(java.util.Comparator)>
<java.util.LinkedList: boolean remove(java.lang.Object)>	<java.util.LinkedList: boolean remove(java.lang.Object)>
<Neighbor: Vertex getEnd()>	<Neighbor: Vertex getEnd()>	@GN_OnlyNeighbors
<<\\" FinishTime -> \\">>	<<\\" FinishTime -> \\">>	@StronglyConnected
<java.util.Iterator: java.lang.Object next()>	<java.util.Iterator: java.lang.Object next()>
<java.lang.String: void <init>(java.lang.String)>	<java.lang.String: void <init>(java.lang.String)>
<java.io.FileReader: void <init>(java.lang.String)>	<java.io.FileReader: void <init>(java.lang.String)>
<java.lang.StringBuilder: java.lang.String toString()>	<java.lang.StringBuilder: java.lang.String toString()>
<Graph: Graph prim(Vertex)>	<Graph: Graph prim(Vertex)>
<FinishTimeWorkSpace: void <init>()>	<FinishTimeWorkSpace: void <init>()>
<Graph: EdgeIter getEdges()>	<Graph: EdgeIter getEdges()>
<Vertex$VertexIter3: Vertex next()>	<Vertex$VertexIter3: Vertex next()>	@GEN_Edges
<VertexIter: boolean hasNext()>	<VertexIter: boolean hasNext()>
<java.lang.String: java.lang.String trim()>	<java.lang.String: java.lang.String trim()>
<Vertex$EdgeIter2: void <init>(Vertex)>	<Vertex$EdgeIter2: void <init>(Vertex)>
<Graph: void resumeProfile()>	<Graph: void resumeProfile()>	@Benchmark
<java.io.PrintStream: void println(java.lang.String)>	<java.io.PrintStream: void println(java.lang.String)>
<java.lang.StringBuilder: java.lang.StringBuilder append(long)>	<java.lang.StringBuilder: java.lang.StringBuilder append(long)>
<Graph: void addVertex(Vertex)>	<Graph: void addVertex(Vertex)>
<Neighbor: void adjustAdorns(EdgeIfc)>	<Neighbor: void adjustAdorns(EdgeIfc)>	@GN_OnlyNeighbors
<<\\"Time elapsed: \\">>	<<\\"Time elapsed: \\">>	@(Benchmark) /\ (Benchmark)
<java.util.LinkedList: void clear()>	<java.util.LinkedList: void clear()>
<Graph: void endProfile()>	<Graph: void endProfile()>	@Benchmark
<EdgeIter: EdgeIfc next()>	<EdgeIter: EdgeIfc next()>
<Graph: void run(Vertex)>	<Graph: void run(Vertex)>
<Graph$Comparator2: void <init>(Graph)>	<Graph$Comparator2: void <init>(Graph)>
<java.io.PrintStream: void println()>	<java.io.PrintStream: void println()>
<Vertex: int getWeight()>	<Vertex: int getWeight()>	@G_NoEdges
<java.util.LinkedList: void <init>()>	<java.util.LinkedList: void <init>()>
<GlobalVarsWrapper: void <init>()>	<GlobalVarsWrapper: void <init>()>
<Graph: void numberVertices()>	<Graph: void numberVertices()>	@Number
<<\\"Vertex \\">>	<<\\"Vertex \\">>
v	v	@(Prog) /\ (Prog)
<Main: void <init>()>	<Main: void <init>()>
<<\\"Total Time: \\">>	<<\\"Total Time: \\">>	@(Prog) /\ (Prog)
<java.lang.Integer: int intValue()>	<java.lang.Integer: int intValue()>
<EdgeIfc: void adjustAdorns(EdgeIfc)>	<EdgeIfc: void adjustAdorns(EdgeIfc)>
<Vertex: void addAdjacent(Vertex)>	<Vertex: void addAdjacent(Vertex)>	@G_NoEdges
<<\\" # \\">>	<<\\" # \\">>	@Number
<Edge: Vertex getStart()>	<Edge: Vertex getStart()>	@EdgeObjects
<<\\" Cycle? \\">>	<<\\" Cycle? \\">>	@Cycle /\ Prog
<Vertex: Vertex getEnd()>	<Vertex: Vertex getEnd()>	@G_NoEdges
<Vertex$VertexIter2: void <init>(Vertex)>	<Vertex$VertexIter2: void <init>(Vertex)>
<VertexIter: void <init>()>	<VertexIter: void <init>()>
<java.io.Reader: void close()>	<java.io.Reader: void close()>
<java.util.LinkedList: java.lang.Object set(int,java.lang.Object)>	<java.util.LinkedList: java.lang.Object set(int,java.lang.Object)>
<Neighbor: void <init>(Vertex,int)>	<Neighbor: void <init>(Vertex,int)>
<Vertex: Vertex assignName(java.lang.String)>	<Vertex: Vertex assignName(java.lang.String)>
<Vertex: void adjustAdorns(EdgeIfc)>	<Vertex: void adjustAdorns(EdgeIfc)>	@G_NoEdges
<java.lang.Object: boolean equals(java.lang.Object)>	<java.lang.Object: boolean equals(java.lang.Object)>
<Edge: Vertex getEnd()>	<Edge: Vertex getEnd()>	@EdgeObjects
<java.util.Collections: int binarySearch(java.util.List,java.lang.Object,java.util.Comparator)>	<java.util.Collections: int binarySearch(java.util.List,java.lang.Object,java.util.Comparator)>
<<\\"  visited\\">>	<<\\"  visited\\">>	@SearchBase
<<\\" Weights : \\">>	<<\\" Weights : \\">>	@Weighted /\ G_NoEdges
<java.util.LinkedList: java.lang.Object getLast()>	<java.util.LinkedList: java.lang.Object getLast()>
<Neighbor: Vertex getStart()>	<Neighbor: Vertex getStart()>	@GN_OnlyNeighbors
<<\\" Weight=\\">>	<<\\" Weight=\\">>	@(EdgeObjects) /\ (EdgeObjects /\ Weighted)
<Graph: boolean cycleCheck()>	<Graph: boolean cycleCheck()>	@Cycle
<Vertex: EdgeIter getEdges()>	<Vertex: EdgeIter getEdges()>	@EdgeObjects /\ G_NoEdges
<WorkSpaceTranspose: void preVisitAction(Vertex)>	<WorkSpaceTranspose: void preVisitAction(Vertex)>	@StronglyConnected
<Neighbor: void <init>(Vertex,Edge)>	<Neighbor: void <init>(Vertex,Edge)>
<CycleWorkSpace: void <init>()>	<CycleWorkSpace: void <init>()>
<<\\" Pred \\">>	<<\\" Pred \\">>	@MSTPrim
******************************************	******************************************
<Main: EdgeIfc addEdge(Graph,int)>	<Main: EdgeIfc addEdge(Graph,int)>	@Prog
<<\\" Rep \\">>	<<\\" Rep \\">>	@MSTKruskal
<Graph$Comparator1: void <init>(Graph)>	<Graph$Comparator1: void <init>(Graph)>
<Graph: int readNumber()>	<Graph: int readNumber()>	@Benchmark
<Vertex: void addNeighbor(Neighbor)>	<Vertex: void addNeighbor(Neighbor)>	@GEN_Edges
<CycleWorkSpace: void checkNeighborAction(Vertex,Vertex)>	<CycleWorkSpace: void checkNeighborAction(Vertex,Vertex)>
<Graph$Comparator1: int compare(java.lang.Object,java.lang.Object)>	<Graph$Comparator1: int compare(java.lang.Object,java.lang.Object)>
<FinishTimeWorkSpace: void postVisitAction(Vertex)>	<FinishTimeWorkSpace: void postVisitAction(Vertex)>	@StronglyConnected
<WorkSpace: void postVisitAction(Vertex)>	<WorkSpace: void postVisitAction(Vertex)>	@SearchBase
<GlobalVarsWrapper: void <clinit>()>	<GlobalVarsWrapper: void <clinit>()>	@BFS
<java.lang.String: boolean equals(java.lang.Object)>	<java.lang.String: boolean equals(java.lang.Object)>
<<\\" !visited\\">>	<<\\" !visited\\">>	@SearchBase
<java.lang.StringBuilder: java.lang.StringBuilder append(int)>	<java.lang.StringBuilder: java.lang.StringBuilder append(int)>
<Graph: Vertex findsVertex(java.lang.String)>	<Graph: Vertex findsVertex(java.lang.String)>
<Graph$Comparator2: void <init>(Graph,Graph$Comparator2)>	<Graph$Comparator2: void <init>(Graph,Graph$Comparator2)>
<Vertex$EdgeIter1: void <init>(Vertex)>	<Vertex$EdgeIter1: void <init>(Vertex)>
<RegionWorkSpace: void postVisitAction(Vertex)>	<RegionWorkSpace: void postVisitAction(Vertex)>	@Connected
<CycleWorkSpace: void preVisitAction(Vertex)>	<CycleWorkSpace: void preVisitAction(Vertex)>
<WorkSpaceTranspose: void <init>()>	<WorkSpaceTranspose: void <init>()>
<java.util.LinkedList: int size()>	<java.util.LinkedList: int size()>
<Graph$Comparator3: int compare(java.lang.Object,java.lang.Object)>	<Graph$Comparator3: int compare(java.lang.Object,java.lang.Object)>
<<\\"Edges \\">>	<<\\"Edges \\">>	@GEN_Edges
<NumberWorkSpace: void <init>()>	<NumberWorkSpace: void <init>()>
<Graph: Graph strongComponents()>	<Graph: Graph strongComponents()>
<Graph: EdgeIfc addEdge(Vertex,Vertex,int)>	<Graph: EdgeIfc addEdge(Vertex,Vertex,int)>
<EdgeIfc: Vertex getEnd()>	<EdgeIfc: Vertex getEnd()>
<Graph: VertexIter getVertices()>	<Graph: VertexIter getVertices()>
<Vertex: void init_vertex(WorkSpace)>	<Vertex: void init_vertex(WorkSpace)>	@SearchBase
<Graph$Comparator2: int compare(Vertex,Vertex)>	<Graph$Comparator2: int compare(Vertex,Vertex)>	@MSTPrim
<Graph$Comparator3: int compare(EdgeIfc,EdgeIfc)>	<Graph$Comparator3: int compare(EdgeIfc,EdgeIfc)>	@MSTKruskal
<Graph: void graphSearch(WorkSpace)>	<Graph: void graphSearch(WorkSpace)>
<<\\"Vertices \\">>	<<\\"Vertices \\">>
<EdgeIfc: void display()>	<EdgeIfc: void display()>
<Vertex: Vertex getOtherVertex(Vertex)>	<Vertex: Vertex getOtherVertex(Vertex)>	@G_NoEdges
<EdgeIter: void <init>()>	<EdgeIter: void <init>()>
<Vertex: void nodeSearch(WorkSpace)>	<Vertex: void nodeSearch(WorkSpace)>
<java.lang.String: java.lang.String substring(int,int)>	<java.lang.String: java.lang.String substring(int,int)>
<<\\" start=\\">>	<<\\" start=\\">>	@(EdgeObjects) /\ (EdgeObjects)
<java.util.LinkedList: void add(int,java.lang.Object)>	<java.util.LinkedList: void add(int,java.lang.Object)>
<Vertex: void <init>()>	<Vertex: void <init>()>
<Vertex$VertexIter1: void <init>(Vertex,Vertex$VertexIter1)>	<Vertex$VertexIter1: void <init>(Vertex,Vertex$VertexIter1)>
<Vertex$EdgeIter1: EdgeIfc next()>	<Vertex$EdgeIter1: EdgeIfc next()>	@EdgeObjects /\ G_NoEdges
<Vertex: void addWeight(int)>	<Vertex: void addWeight(int)>	@Weighted
<java.util.LinkedList: java.lang.Object removeFirst()>	<java.util.LinkedList: java.lang.Object removeFirst()>
<Graph: void <init>()>	<Graph: void <init>()>
<Neighbor: void <init>()>	<Neighbor: void <init>()>
<CycleWorkSpace: void postVisitAction(Vertex)>	<CycleWorkSpace: void postVisitAction(Vertex)>	@Cycle
<Graph$EdgeIter1: boolean hasNext()>	<Graph$EdgeIter1: boolean hasNext()>	@EdgeObjects
<Edge: void display()>	<Edge: void display()>	@EdgeObjects
<java.io.Reader: int read()>	<java.io.Reader: int read()>
<Graph: void addEdge(Vertex,Neighbor)>	<Graph: void addEdge(Vertex,Neighbor)>	@GN_OnlyNeighbors
<NumberWorkSpace: void preVisitAction(Vertex)>	<NumberWorkSpace: void preVisitAction(Vertex)>
<java.lang.Integer: void <init>(int)>	<java.lang.Integer: void <init>(int)>
<Neighbor: void setWeight(int)>	<Neighbor: void setWeight(int)>	@Weighted /\ GN_OnlyNeighbors
<Vertex$EdgeIter3: EdgeIfc next()>	<Vertex$EdgeIter3: EdgeIfc next()>	@EdgeObjects /\ GEN_Edges
******************************************	******************************************	@GEN_Edges
<Vertex: VertexIter getNeighbors()>	<Vertex: VertexIter getNeighbors()>	@G_NoEdges
<java.lang.System: long currentTimeMillis()>	<java.lang.System: long currentTimeMillis()>
<Vertex: void adjustAdorns(Neighbor)>	<Vertex: void adjustAdorns(Neighbor)>	@GN_OnlyNeighbors
<java.util.HashSet: void <init>()>	<java.util.HashSet: void <init>()>
<EdgeIfc: Vertex getStart()>	<EdgeIfc: Vertex getStart()>
<Vertex: void display()>	<Vertex: void display()>
<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>	<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>
<java.util.LinkedList: java.util.Iterator iterator()>	<java.util.LinkedList: java.util.Iterator iterator()>
<Graph$Comparator1: int compare(Vertex,Vertex)>	<Graph$Comparator1: int compare(Vertex,Vertex)>	@StronglyConnected
<WorkSpace: void nextRegionAction(Vertex)>	<WorkSpace: void nextRegionAction(Vertex)>	@SearchBase
<VertexIter: Vertex next()>	<VertexIter: Vertex next()>
<RegionWorkSpace: void init_vertex(Vertex)>	<RegionWorkSpace: void init_vertex(Vertex)>	@Connected
<java.util.Set: boolean remove(java.lang.Object)>	<java.util.Set: boolean remove(java.lang.Object)>
<FinishTimeWorkSpace: void preVisitAction(Vertex)>	<FinishTimeWorkSpace: void preVisitAction(Vertex)>	@StronglyConnected
<Vertex$EdgeIter2: boolean hasNext()>	<Vertex$EdgeIter2: boolean hasNext()>	@EdgeObjects /\ GN_OnlyNeighbors
<java.util.LinkedList: java.lang.Object get(int)>	<java.util.LinkedList: java.lang.Object get(int)>
<java.lang.Object: void <init>()>	<java.lang.Object: void <init>()>
<Graph$EdgeIter1: EdgeIfc next()>	<Graph$EdgeIter1: EdgeIfc next()>	@EdgeObjects
<WorkSpace: void preVisitAction(Vertex)>	<WorkSpace: void preVisitAction(Vertex)>	@SearchBase
<Vertex$EdgeIter2: EdgeIfc next()>	<Vertex$EdgeIter2: EdgeIfc next()>	@EdgeObjects /\ GN_OnlyNeighbors
<Vertex: void setWeight(int)>	<Vertex: void setWeight(int)>	@Weighted /\ G_NoEdges
<Edge: int getWeight()>	<Edge: int getWeight()>	@EdgeObjects /\ Weighted
<java.util.Set: boolean contains(java.lang.Object)>	<java.util.Set: boolean contains(java.lang.Object)>
<Graph: java.util.LinkedList access$0(Graph)>	<Graph: java.util.LinkedList access$0(Graph)>
<Vertex$VertexIter2: Vertex next()>	<Vertex$VertexIter2: Vertex next()>	@GN_OnlyNeighbors
<WorkSpaceTranspose: void nextRegionAction(Vertex)>	<WorkSpaceTranspose: void nextRegionAction(Vertex)>	@StronglyConnected
<java.io.PrintStream: void print(java.lang.String)>	<java.io.PrintStream: void print(java.lang.String)>
<<\\" VertexCycle# \\">>	<<\\" VertexCycle# \\">>	@Cycle
<Graph: void stopProfile()>	<Graph: void stopProfile()>	@Benchmark
<Vertex$VertexIter3: void <init>(Vertex)>	<Vertex$VertexIter3: void <init>(Vertex)>
<Graph: void startProfile()>	<Graph: void startProfile()>	@Benchmark
<Vertex$VertexIter3: boolean hasNext()>	<Vertex$VertexIter3: boolean hasNext()>	@GEN_Edges
<Graph: void connectedComponents()>	<Graph: void connectedComponents()>	@Connected
<Neighbor: Vertex getOtherVertex(Vertex)>	<Neighbor: Vertex getOtherVertex(Vertex)>	@GN_OnlyNeighbors
<Graph$Comparator3: void <init>(Graph)>	<Graph$Comparator3: void <init>(Graph)>
<java.util.Collections: void sort(java.util.List,java.util.Comparator)>	<java.util.Collections: void sort(java.util.List,java.util.Comparator)>
<Vertex: Vertex getStart()>	<Vertex: Vertex getStart()>	@Undirected /\ G_NoEdges
<java.lang.String: java.lang.String valueOf(int)>	<java.lang.String: java.lang.String valueOf(int)>
<Graph: void sortEdges(java.util.Comparator)>	<Graph: void sortEdges(java.util.Comparator)>	@EdgeObjects
<Graph$Comparator1: void <init>(Graph,Graph$Comparator1)>	<Graph$Comparator1: void <init>(Graph,Graph$Comparator1)>
<WorkSpace: void <init>()>	<WorkSpace: void <init>()>
<Graph: void display()>	<Graph: void display()>
<RegionWorkSpace: void <init>()>	<RegionWorkSpace: void <init>()>
<Graph: Graph computeTranspose(Graph)>	<Graph: Graph computeTranspose(Graph)>	@Transpose
<java.lang.StringBuilder: void <init>(java.lang.String)>	<java.lang.StringBuilder: void <init>(java.lang.String)>
<Edge: void setWeight(int)>	<Edge: void setWeight(int)>	@EdgeObjects /\ Weighted
<RegionWorkSpace: void nextRegionAction(Vertex)>	<RegionWorkSpace: void nextRegionAction(Vertex)>	@Connected
<CycleWorkSpace: void init_vertex(Vertex)>	<CycleWorkSpace: void init_vertex(Vertex)>	@Cycle
<java.util.HashMap: void <init>()>	<java.util.HashMap: void <init>()>
<Graph$Comparator3: void <init>(Graph,Graph$Comparator3)>	<Graph$Comparator3: void <init>(Graph,Graph$Comparator3)>
<Vertex: java.lang.String getName()>	<Vertex: java.lang.String getName()>
<EdgeIfc: Vertex getOtherVertex(Vertex)>	<EdgeIfc: Vertex getOtherVertex(Vertex)>
<Vertex$EdgeIter3: void <init>(Vertex)>	<Vertex$EdgeIter3: void <init>(Vertex)>
<WorkSpace: void checkNeighborAction(Vertex,Vertex)>	<WorkSpace: void checkNeighborAction(Vertex,Vertex)>	@SearchBase
<Vertex$VertexIter1: Vertex next()>	<Vertex$VertexIter1: Vertex next()>	@G_NoEdges
<Vertex$EdgeIter3: boolean hasNext()>	<Vertex$EdgeIter3: boolean hasNext()>	@EdgeObjects /\ GEN_Edges
<Vertex$VertexIter1: void <init>(Vertex)>	<Vertex$VertexIter1: void <init>(Vertex)>
<VertexIter: void <init>(Graph)>	<VertexIter: void <init>(Graph)>
<EdgeIfc: int getWeight()>	<EdgeIfc: int getWeight()>
<Vertex: void adjustAdorns(Vertex,int)>	<Vertex: void adjustAdorns(Vertex,int)>	@G_NoEdges
<Vertex: void addEdge(Neighbor)>	<Vertex: void addEdge(Neighbor)>	@GN_OnlyNeighbors
<<\\"Rep null \\">>	<<\\"Rep null \\">>	@MSTKruskal
<<\\"Your file \\">>	<<\\"Your file \\">>	@(Benchmark) /\ (Benchmark)
<java.util.LinkedList: boolean add(java.lang.Object)>	<java.util.LinkedList: boolean add(java.lang.Object)>
<Graph: void <clinit>()>	<Graph: void <clinit>()>
<Main: void readWeights(Graph,int)>	<Main: void readWeights(Graph,int)>	@Prog
<Vertex$EdgeIter1: void <init>(Vertex,Vertex$EdgeIter1)>	<Vertex$EdgeIter1: void <init>(Vertex,Vertex$EdgeIter1)>
<java.lang.String: java.lang.String valueOf(java.lang.Object)>	<java.lang.String: java.lang.String valueOf(java.lang.Object)>
<Main: void main(java.lang.String[])>	<Main: void main(java.lang.String[])>	@Prog
<Graph$Comparator2: int compare(java.lang.Object,java.lang.Object)>	<Graph$Comparator2: int compare(java.lang.Object,java.lang.Object)>
<Vertex$VertexIter2: boolean hasNext()>	<Vertex$VertexIter2: boolean hasNext()>	@GN_OnlyNeighbors
<java.util.Set: boolean add(java.lang.Object)>	<java.util.Set: boolean add(java.lang.Object)>
<Neighbor: void display()>	<Neighbor: void display()>	@GN_OnlyNeighbors
<java.lang.String: void <init>(char[])>	<java.lang.String: void <init>(char[])>
<Vertex$VertexIter1: boolean hasNext()>	<Vertex$VertexIter1: boolean hasNext()>	@G_NoEdges
<Vertex$EdgeIter1: boolean hasNext()>	<Vertex$EdgeIter1: boolean hasNext()>	@EdgeObjects /\ G_NoEdges
<Graph: EdgeIfc findsEdge(Vertex,Vertex)>	<Graph: EdgeIfc findsEdge(Vertex,Vertex)>	@EdgeObjects
<Edge: void <init>(Vertex,Vertex,int)>	<Edge: void <init>(Vertex,Vertex,int)>
