je.disable.java5.latches
java.util.concurrent.locks.ReentrantLock
java.util.concurrent.locks.ReentrantReadWriteLock
LatchImpl
ABORT
CASCADE
NULLIFY
ForeignKeyDeleteAction.
activeTxns=[
]\n
<<\\"usage: \\">>
\\\" gTxnId=\\\"
null
\\\" bqual=\\\"
null
\\\"/>
<DbPrintLog>
</DbPrintLog>
exactParentFound=
null
-h requires an argument
.
-h is a required argument
File 0x
<<\\"A per-thread transaction was created in \\">>
<<\\"Usage: \\">>
<<\\"  File    Size (KB)  % Used\n--------  ---------  ------\\">>
<<\\" -h  <envHomeDir>\\">>
<<\\" -e  <end file number, in hex>\\">>
<<\\" -k  <binary|text> (format for dumping the key)\\">>
<<\\" -s  <start file number, in hex>\\">>
\n
\\"CleanIN:\\"
\\"CleanLN:\\"
\\"CleanMigrateLN:\\"
\\"CleanPendingLN:\\"
<<\\" -tx <targetted txn ids, comma separated>\\">>
<<\\" -ty <targetted entry types, comma separated>\\">>
<<\\" -S  show Summary of log entries\\">>
<<\\" -q  if specified, concise version is printed\\">>
<<\\"     Default is verbose version.)\\">>
All arguments are optional
TxnPrepare
\\\">
Channel closed, may be due to thread interrupt
>
<<\\"Both \\">>
)
<<\\"<LATCH \\">>
<<\\"] \\">>
<<\\"\\">>
]
<<\\" [waiters: \\">>
<<\\" \\">>
]
>
\\"<bin>\\"
\\"</bin>\\"
<<\\"\\">>
fsyncLatch
<<\\"Cleaner has \\">>
.del
Cleaner deleted file 0x
Log file 0x
deleted
renamed
Cleaner
deleteSafeToDeleteFiles
<knownDeleted val=\\\"
nodeId=
true
false
\\\"/>
CleanPendingLN:
CleanPendingLN:
CleanPendingLN:
CleanPendingLN:
<<\\"failed adding in \\">>
CleanPendingLN:
CleanPendingLN:
CleanPendingLN:
size=
db=
BIN must be latched before evicting LNs
CleanMigrateLN:
CleanMigrateLN:
<bin>
</bin>
BIN
<<\\"Cannot read backward over cleaned file from \\">>
Sequences not supported in databases configured for duplicates
Minimum sequence value must be less than the maximum
CleanMigrateLN:
Initial sequence value is out of range
The cache size is larger than the sequence range
ExclusiveCreate=true and the sequence record already exists.
<<\\"FileReader read invalid log entry type: \\">>
Sequence record removed during openSequence.
AllowCreate=false and the sequence record does not exist.
<<\\"Dup Offset \\">>
Sequence delta must be greater than zero
Sequence delta is larger than the range
<<\\"Sequence overflow \\">>
<key v=\\\"
<null>
<null>
<<\\"\\">>
\\\"/>
key=
<<\\"<LatchWaiter: \\">>
\\"                                                                                                                                \\"
<<\\"                                                                                                                                \\">>
Sequence.get value=
<<\\" \\">>
null
\\";\\"
<<\\"Problem in fillReadBuffer, readBufferFileNum = \\">>
<<\\" A configuration parameter name can\'t be null or 0 length\\">>
The sequence record has been deleted while it is open.
DEFAULT
READ_UNCOMMITTED
READ_COMMITTED
RMW
LockMode.
<dbId id=\\\"
\\\"/>
\\"je.properties\\"
envHome
<DatabaseEntry
>
je.properties
<<\\"An error occurred when reading \\">>
\\"<dbin>\\"
\\"</dbin>\\"
\\"<in>\\"
\\"</in>\\"
\\"Split:\\"
\\"Delete:\\"
<<\\"There \\">>
is 1 open Database in the Environment.\n
<<\\"are \\">>
<<\\" open Database in the Environment.\n\\">>
Closing the following databases:\n
<<\\" \\">>
<<\\"There \\">>
is 1 existing transaction opened against
<<\\" the Environment.\n\\">>
<<\\"are \\">>
<<\\" existing transactions opened against\\">>
<<\\" the Environment.\n\\">>
Aborting open transactions ...\n
<dbin>
</dbin>
<dupkey>
<<\\"\\">>
</dupkey>
databaseName
Environment.open:  name=
DBIN
<<\\"Database \\">>
<<\\"Database \\">>
<<\\"Attempted to open Database \\">>
<<\\"Attempted to open Database \\">>
databaseName
\\\"/>
databaseName
newName
<<\\"CleanAddPendingDB \\">>
<<\\" node=\\">>
<<\\" logLsn=\\">>
databaseName
<<\\"Shutting down \\">>
Exiting
Continuing
Transactions can not be used in a non-transactional environment
Only one may be specified: SerializableIsolation, ReadCommitted or ReadUncommitted
Non-blocking lock was denied.
api
sync
mutableConfig
A checksum error was found in the log.
<<\\"Corruption begins at LSN:\n   \\">>
<<\\"Last known good record before corruption is at LSN:\n   \\">>
<<\\"Next known good record after corruption is at LSN:\n   \\">>
Attempt to use non-open Environment object().
NULL_LSN without KnownDeleted
<<\\"\\">>
remaining=
delete
<<\\"SecondaryCursor.delete: \\">>
<<\\"fetchTarget of \\">>
null lsn
txnId=
\\"    Cache Size      Btree Size  Description\n--------------  --------------  -----------\\"
<<\\"SecondaryCursor.getCurrent: \\">>
\n
<<\\"SecondaryCursor.getFirst: \\">>
<<\\"-Warning: Out of sync. Should be \\">>
<<\\"SecondaryCursor.getLast: \\">>
<<\\"SecondaryCursor.getNext: \\">>
<<\\"SecondaryCursor.getNextDup: \\">>
<<\\"SecondaryCursor.getNextNoDup: \\">>
No value after -records
No value after -key
No value after -data
<<\\"SecondaryCursor.getPrev: \\">>
No value after -nodemax
No value after -density
No value after -overhead
<<\\"SecondaryCursor.getPrevDup: \\">>
No value after -measure
<<\\"Unknown arg: \\">>
<<\\"SecondaryCursor.getPrevNoDup: \\">>
-records not specified
-key not specified
key
pKey
data
<<\\"SecondaryCursor.getSearchKey: \\">>
key
pKey
data
<<\\"SecondaryCursor.getSearchKeyRange: \\">>
<<\\"prepare() has already been called for Transaction \\">>
<<\\"Transaction \\">>
key
pKey
data
<<\\"SecondaryCursor.getSearchBoth: \\">>
key
pKey
data
<<\\"SecondaryCursor.getSearchBothRange: \\">>
<<\\"Node \\">>
<<\\"usage:\njava \\">>
<<\\"Transaction \\">>
<<\\"Commit of transaction \\">>
Txn
commit
<<\\"Failed while attempting to commit transaction \\">>
<<\\"Failed while attempting to commit transaction \\">>
Inputs: records=
idkey is null
<<\\"    Cache Size      Btree Size  Description\n--------------  --------------  -----------\\">>
Minimum, internal nodes only
Maximum, internal nodes only
Minimum, internal nodes and leaf nodes
Maximum, internal nodes and leaf nodes
\nTo get leaf node sizing specify -data
<<\\"\nBtree levels: \\">>
key
pKey
data
<<\\"Abort:id = \\">>
<<\\"Transaction \\">>
<<\\"Directory is not empty: \\">>
<<\\"\nMeasuring with cache size: \\">>
Stats for internal and leaf nodes (after insert)
<<\\"\nPreloading with cache size: \\">>
Stats for internal nodes only (after preload)
<<\\"During close: \\">>
<<\\"During close: \\">>
foo
<<\\"IN \\">>
<<\\"IN \\">>
Txn undo for node=
Log statistics:
type
total
provisional
total
min
max
avg
entries
<<\\"\\">>
count
count
bytes
bytes
bytes
bytes
as % of log
<<\\"Found non-deletable IN \\">>
*** Key doesn\'t fit value=
Random key already exists -- retrying
key/data
<<\\"\\">>
<<\\"\\">>
<<\\"\\">>
<<\\"\\">>
<<\\"\\">>
(
<<\\"\nTotal bytes in portion of log read: \\">>
<<\\"Total number of entries: \\">>
<<\\"*** \\">>
<<\\"*** Ran out of cache memory at record \\">>
<<\\" \\">>
.
<<\\"Invalid value of searchType: \\">>
\nPer checkpoint interval info:
lnTxn
ln
mapLNTxn
mapLN
end-end
end-start
start-end
maxLNReplay
ckptEnd
CacheSize=
*** All records did not fit in the cache ***
<<\\"DatabaseEntry \\">>
<<\\"Data field for DatabaseEntry \\">>
A partial key DatabaseEntry is not allowed
<<\\"usage: \\">>
<<\\"Couldn\'t find lock for Node \\">>
-f requires an argument
-h requires an argument
-d requires an argument
-s requires an argument
-h is a required argument
Must supply a database name if -l not supplied.
true
false
<<\\"DbDump.dump of \\">>
DATA=END
<<\\"DbDump.dump of \\">>
VERSION=3
<<\\"Can\'t find \\">>
format=print
format=bytevalue
type=btree
dupsort=
<<\\"Can\'t find \\">>
1
0
HEADER=END
<<\\"Transaction \\">>
<<\\"Transaction \\">>
\\"RootSplit:\\"
\\"DupRootSplit:\\"
\\"Mut:\\"
\\"Ins:\\"
\\"InsD:\\"
<txn id=\\\"
\\\">
</txn>
RootLatch
<summary totalCount=\\\"
\\\" totalSize=\\\"
\\\" totalINCount=\\\"
\\\" totalINSize=\\\"
\\\" totalLNCount=\\\"
\\\" totalLNSize=\\\"
\\\" obsoleteINCount=\\\"
\\\" obsoleteLNCount=\\\"
\\\"/>
<isRoot val=\\\"
\\\"/>
<level val=\\\"
\\\"/>
<entries numEntries=\\\"
\\\" length=\\\"
\\\" baseFileNumber=\\\"
\\\">
\\\">
</ref>
</entries>
<in>
</in>
idKey=
primaryDatabase
Can\'t use as primary:
<<\\"Duplicates must not be allowed for a primary database: \\">>
Primary and secondary databases must be in the same environment
secConfig.getKeyCreator() and getMultiKeyCreator() may not both be non-null
secConfig and getKeyCreator()/getMultiKeyCreator() may be null only if the primary database is read-only
secConfig.getForeignKeyNullifier() and getForeignMultiKeyNullifier() may not both be non-null
ForeignKeyNullifier or ForeignMultiKeyNullifier must be non-null when ForeignKeyDeleteAction is NULLIFY
ForeignKeyNullifier may not be used with SecondaryMultiKeyCreator -- use ForeignMultiKeyNullifier instead
<<\\"Duplicates must not be allowed for a foreign key  database: \\">>
<idkey>
<<\\"\\">>
</idkey>
\\\"/>
\\\"/>
<level val=\\\"
\\\"/>
\\\"/>
<entries nEntries=\\\"
\\\">
<entry id=\\\"
<lsn/>
<key/>
<target/>
\\\"/>
</entry>
</entries>
<knownDeleted val=\\\"
\\\"/>
<pendingDeleted val=\\\"
\\\"/>
IN
getFirstNode passed null root
<<\\"Secondary is already associated with a different primary: \\">>
getLastNode passed null root
Split:
<<\\" parent=\\">>
SecondaryDatabase open
----- Event Dump -----
<<\\" child=\\">>
<<\\" newSibling=\\">>
<<\\" parentLsn = \\">>
<<\\" childLsn = \\">>
<<\\" newSiblingLsn = \\">>
<<\\" splitIdx=\\">>
<<\\" idKeyIdx=\\">>
OPEN
CLOSED
INVALID
<<\\" childIdx=\\">>
Delete:
<<\\" index=\\">>
DatabaseConfig.setReadOnly() must be set to false when creating a Database
SUCCESS
FILLED_CACHE
EXCEEDED_TIME
PreloadStatus.
getParentNode passed null
key
Can\'t call SecondaryDatabase.delete:
<<\\"You can\'t open a Database with a duplicatesAllowed configuration of \\">>
SecondaryDatabase.delete
<<\\"You can\'t open a Database with a transactional configuration of \\">>
<<\\"Environment invalid because of previous exception: \\">>
Can\'t close Database:
<<\\"Database.close: \\">>
There are open cursors against the database.\n
They will be closed.\n
key
pKey
data
<<\\"Wrong filenum in header for file \\">>
Can\'t call SecondaryDatabase.get:
key
SecondaryDatabase.get
Can\'t call Database.openSequence:
openSequence
Database.openSequence
This statement would have triggered an Exception: virtualinvoke searchResult#1.<com.sleepycat.je.tree.IN: void releaseLatchIfOwner()>()
Can\'t open a cursor
Only one may be specified: ReadCommitted or ReadUncommitted
Database.openCursor
<<\\"Expected log version 3 or earlier but found \\">>
key
key
pKey
Can\'t call Database.delete:
data
delete
Database.delete
Can\'t call SecondaryDatabase.getSearchBoth:
<FileHeader num=\\\"0x
SecondaryDatabase.getSearchBoth
\\\" lastEntryInPrevFileOffset=\\\"0x
\\\" logVersion=\\\"0x
\\\"/>
.
key
data
Can\'t call Database.get:
Database.get
key
data
Can\'t call Database.getSearchBoth:
Database.getSearchBoth
key
data
Can\'t call Database.put
put
Database.put
key
data
Can\'t call Database.putNoOverWrite
putNoOverwrite
Database.putNoOverwrite
key
data
Can\'t call Database.putNoDupData
putNoDupData
Database.putNoDupData
<<\\"Secondary \\">>
<<\\"Secondary \\">>
<<\\"Could not insert secondary key in \\">>
subtree did not have a BIN for leaf
Can\'t call Database.join
cursors
At least one cursor is required.
All cursors must use the same transaction.
.
All cursors must use the same environment.
<<\\"Secondary \\">>
All cursors must use the same transaction.
RootSplit:
Can\'t call Database.truncate
truncate
true
false
Database.truncate: txnId=
null
false
1000
<<\\"Files cleaned: \\">>
<<\\"Secondary \\">>
Operation not allowed on a secondary
<<\\"\nrecovery time = \\">>
couldn\'t find database - truncate
truncate
<<\\"action time = \\">>
<<\\"\nrecovery time = \\">>
<<\\"action time = \\">>
Can\'t call Database.preload
preload
<<\\"\nrecovery time = \\">>
<<\\"action time = \\">>
Can\'t call Database.preload
preload
Can\'t call Database.preload
preload
Can\'t call Database.stat
stat
cleanedCount=
<<\\"Remove of \\">>
Can\'t call Database.verify
verify
<offsets size=\\\"
\\\">
0x
Preload starting
</offsets>
<offsets size=\\\"0\\\"/>
searchSubTree passed key and left/right search
<<\\"Preloaded \\">>
\\"je.info\\"
<<\\"Invalid value of searchType: \\">>
evict time=
<<\\"Usage: \n \\">>
<<\\"  -h <environment home> \\">>
<<\\"  -a <clean|compress|evict|checkpoint|removedb>\\">>
<<\\"  -ro (read-only - defaults to read-write)\\">>
<<\\"  -s <dbName> (for preloading of evict or db remove)\\">>
<<\\"Problem parsing parameter \\">>
<<\\"Database is Read Only: \\">>
<Dbg time=\\\"
\\\">
<msg val=\\\"
\\\"/>
</Dbg>
<<\\"\\">>
\\\"/>
<<\\" name=\\">>
non LogEntryType passed to LogEntryType.compare
\\"_jeIdMap\\"
\\"_jeNameMap\\"
\\"_jeUtilization\\"
_jeIdMap
_jeNameMap
_jeUtilization
_jeIdMap
_jeNameMap
_jeIdMap
_jeNameMap
NEW
WAIT_NEW
PROMOTION
WAIT_PROMOTION
EXISTING
DENIED
WAIT_RESTART
NONE_NEEDED
\\"<fileSummaryLN>\\"
\\"</fileSummaryLN>\\"
UTF-8
<fileSummaryLN>
</fileSummaryLN>
<<\\"can\'t find database \\">>
Txnl access to UP db not allowed
<<\\"Attempted to \\">>
<<\\"Logged item entrySize= \\">>
<<\\"Can\'t \\">>
rename
remove
truncate
<<\\"Read non-valid log entry type: \\">>
Channel closed, may be due to thread interrupt
<<\\"null buffer given to checksum validation, probably  result of 0\'s in log file. \\">>
<<\\"Location \\">>
<<\\"Database \\">>
<<\\"Can\'t truncate database \\">>
\\"<node>\\"
\\"</node>\\"
<<\\"Location \\">>
This statement would have triggered an Exception: virtualinvoke dupRoot#4.<com.sleepycat.je.tree.DIN: void releaseLatch()>()
matchLNByNodeId called on non DIN/DBIN
neither LN or DIN found in BIN
<node>
</node>
<
<node>
</node>
DupRootSplit:
<<\\"Cursor.count: \\">>
delete
<<\\"Cursor.delete: \\">>
key
data
put
<<\\"Cursor.put: \\">>
key
data
putNoOverwrite
<<\\"Cursor.putNoOverwrite: \\">>
key
data
putNoDupData
<<\\"Cursor.putNoDupData: \\">>
data
putCurrent
<<\\"Cursor.putCurrent: \\">>
<<\\"Cursor.getCurrent: \\">>
<<\\"Cursor.getFirst: \\">>
<<\\"Cursor.getLast: \\">>
<<\\"Cursor.getNext: \\">>
allowDuplicates passed to insert but database doesn\'t have allow duplicates set.
<<\\"Cursor.getNextDup: \\">>
<<\\"Cursor.getNextNoDup: \\">>
<<\\"Cursor.getPrev: \\">>
_jeIdMap
_jeNameMap
<<\\"Cursor.getPrevDup: \\">>
UTF-8
<<\\"Cursor.getPrevNoDup: \\">>
key
data
<<\\"Cursor.getSearchKey: \\">>
UTF-8
key
data
<<\\"SubtreeRemoval: subtreeRoot = \\">>
<<\\"Cursor.getSearchKeyRange: \\">>
<<\\"Cursor.getSearchBoth: \\">>
<root>
<<\\"Cursor.getSearchBothRange: \\">>
</root>
<dbtree lastId = \\\"
\\\">
<idDb>
</idDb><nameDb>
</nameDb>
</dbtree>
<tree>
<in/>
</tree>
<dbTree lastDbId =\\\"
\\\">
</dbtree>
<<\\"IN \\">>
<<\\"IN \\">>
<<\\"IN \\">>
\n
SET
BOTH
SET_RANGE
BOTH_RANGE
SearchMode.
TxnCommit
\\"INCompress:\\"
Mut:
<<\\" existingLn=\\">>
<<\\" newLn=\\">>
<<\\" newLnLsn=\\">>
<<\\" dupCountLN=\\">>
<<\\" dupRootLsn=\\">>
<<\\" rootdin=\\">>
<<\\" ddinLsn=\\">>
LN_TX
<<\\" dbin=\\">>
\\\"/>
<<\\" dbinLsn=\\">>
<<\\" bin=\\">>
LN
MapLN_TX
MapLN
NameLN_TX
NameLN
DelDupLN_TX
DelDupLN
INCompressor.addToQueue should never be called.
DupCountLN_TX
Ins:
DupCountLN
<<\\" bin=\\">>
FileSummaryLN
<<\\" ln=\\">>
IN
<<\\" lnLsn=\\">>
BIN
<<\\" index=\\">>
DIN
DBIN
Root
Commit
put passed a null DatabaseEntry arg
InsD:
put passed a null DatabaseEntry arg
<<\\" dbin=\\">>
<<\\" bin=\\">>
<<\\" ln=\\">>
<<\\" lnLsn=\\">>
unknown PutMode
DbState.
Abort
CkptStart
CkptEnd
INDelete
BINDelta
DupBINDelta
Trace
FileHeader
INDupDelete
Prepare
<<\\"Lock Table \\">>
<<\\"InCompress.doCompress called, queue size: \\">>
Transaction
Lock
Transaction
This statement would have triggered an Exception: $stack45 = result#4.<com.sleepycat.je.dbi.CursorImpl$KeyChangeStatus: com.sleepycat.je.OperationStatus status>
\\"Delete\\"
\\"Mod:\\"
<<\\"Obsolete lsns contains valid lsn \\">>
<<\\"Tree contains obsolete lsn \\">>
Lsn mismatch
++++++++++ begin lock table dump ++++++++++
++++++++++ end lock table dump ++++++++++
: waited for lock
\n
Btree
Duplicate
<<\\"Transfer, lock \\">>
The following DatabaseConfig parameters for the\ncached Database do not match the parameters for the\nrequested Database:\n
<<\\" Transactional\n\\">>
<<\\" Read-Only\n\\">>
<<\\" Sorted Duplicates\n\\">>
<<\\" Btree Comparator\n\\">>
<<\\" Duplicate Comparator\n\\">>
<<\\"Transfer, lock \\">>
Delete
----\n
\n
<<\\" waits for \\">>
<<\\" nothing\\">>
<<\\" node \\">>
\n
<<\\"Transaction \\">>
.
.
.
.
<<\\" (\\">>
)
putNoDupData() called, but database is not configured for duplicate data.
\\\"/>
daemon
unknown GetMode
<<\\" lastCkpt=\\">>
<<\\" lastCkpt=\\">>
Can\'t replace a duplicate with different data.
<<\\" lastCkpt=\\">>
Mod:
<<\\" lastCkpt=\\">>
<<\\" lastCkpt=\\">>
<<\\"A transaction was not supplied when opening this cursor: \\">>
key
data
key
data
\\"je.disable.java.adler32\\"
MapTreeRoot
Can\'t set \'je.env.isNoLocking\' and \'je.env.isTransactional\';
<<\\"Enviroment creation isn\'t allowed,  but there is no pre-existing  environment in \\">>
TriggerLatch
Evictor
Checkpointer
INCompressor
Cleaner
Attempt to use a Environment that has been closed.
\\"usage: java <utility> [options...]\\"
\\"com.sleepycat.je.util.\\"
Missing utility name
com.sleepycat.je.util.
usage: java <utility> [options...]
<<\\"Close of environment \\">>
close
<<\\"\nException shutting down daemon threads: \\">>
\n
<<\\"locker \\">>
<<\\"Env \\">>
<<\\"\nException clearing file manager: \\">>
\n
<<\\"locker \\">>
<<\\"\nException clearing file manager: \\">>
\n
<<\\" Owners:\\">>
<<\\" (none)\\">>
<<\\" Waiters:\\">>
<<\\" (none)\\">>
A Transaction cannot be used because the environment was opened non-transactionally
A Transaction cannot be used because the database was opened non-transactionally
A Transaction cannot be used because the database was opened non-transactionally
<<\\"Problem: \\">>
<<\\"Problem: \\">>
Some latches held at env close.
Lock, transaction, or latch left behind at environment close
A Transaction cannot be used because the database was opened non-transactionally
File Flip
manual
SUCCESS
KEYEXIST
KEYEMPTY
NOTFOUND
OperationStatus.
beginTransaction called,  but Environment was not opened with transactional cpabilities
<<\\"environmentImpl is null for target db \\">>
\\\">
</INDupDeleteEntry>
<<\\"\\">>
\\\">
<ckptStart>
</ckptStart>
<root>
</root>
<firstActive>
</firstActive>
</CkptEnd>
NULL_LSN without KnownDeleted
Already closed
\\\">
key
</ref>
<<\\"JoinCursor.getNext(key): \\">>
<lsn/>
key
data
<key/>
<<\\"JoinCursor.getNext(key,data): \\">>
<target/>
<knownDeleted val=\\\"
\\\"/>
<pendingDeleted val=\\\"
\\\"/>
\\\"/>
BIN cursorSet is inconsistent.
Cursor Not Initialized.
Cursor has been closed.
<<\\"No transaction found for \\">>
<<\\"Unknown cursor status: \\">>
Secondary corrupt
CURSOR_NOT_INITIALIZED
CURSOR_INITIALIZED
CURSOR_CLOSED
UNKNOWN (
<<\\"No transaction found for \\">>
\\"LatchImpl\\"
\\\"
\\\"
\\\"
>\n
<<\\"\\">>
<<\\"\\">>
\n</Cursor>
<<\\"No transaction found for \\">>
LatchImpl
<<\\" bin=\\">>
<<\\" ln=\\">>
<<\\" lnIdx=\\">>
<<\\" oldLnLsn=\\">>
<<\\" newLnLsn=\\">>
waitTarget.active but not owner
\\".jdb\\"
\\".cif\\"
\\".del\\"
\\".bad\\"
\\".lck\\"
.del
.jdb
.jdb
.del
Bad value for timeout:
<<\\"Environment home \\">>
Bad value for timeout:
allowCreate=
nGets=
.jdb
<<\\"Not Exception or Error: \\">>
\\"sun.arch.data.model\\"
\\"je.forceJVMArch\\"
<<\\"usage: \\">>
0000000000000000
0x
<<\\"Exit status = \\">>
1.4 based 64 bit JVM not supported
.jdb
<<\\"Exit status = \\">>
<<\\"Exit status = \\">>
<<\\"\\">>
.
<<\\"Couldn\'t rename \\">>
-h requires an argument
-s requires an argument
-v requires a positive argument
<<\\"Couldn\'t delete \\">>
-v requires an argument
-h is a required argument
-s is a required argument
<<\\"DbVerify.verify of \\">>
Checking obsolete offsets ...
Mac OS X
<<\\"DbVerify.verify of \\">>
<<\\"DbVerify.verify of \\">>
<<\\"Couldn\'t open file \\">>
<<\\"Couldn\'t open file \\">>
<<\\"usage: \\">>
<<\\"usage: \\">>
Channel closed, may be due to thread interrupt
<<\\"IOException caught: \\">>
<<\\"Error in \\">>
,-
<<\\"File \\">>
-h requires an argument
,
-s requires an argument
-
-v requires a positive argument
-v requires an argument
-h is a required argument
-s is a required argument
<<\\"DbStat.stats of \\">>
<<\\"DbStat.stats of \\">>
TxnAbort
Recovery Info
<<\\" lastUsed=\\">>
<<\\" nextAvail=\\">>
<<\\" ckptStart=\\">>
<<\\" firstActive=\\">>
<<\\" ckptEnd=\\">>
<<\\" useRoot=\\">>
>
\\\">
</INDeleteEntry>
FileManager would overwrite non-empty file 0x
.
generated for testing
File closed, may be due to thread interrupt
generated for testing
<<\\"Usage: \\">>
<<\\"                 -h <environment home>\\">>
(optional)
<<\\"                 -f <file number, in hex>\\">>
<<\\"                 -o <offset, in hex>\\">>
Cannot write file summary in a read-only environment
Log file is truncated at position starting at and inclusive of the offset. Beware, not  for general purpose use yet!
.jdb
.bad
lsn=
\\"<din>\\"
\\"</din>\\"
.
.
\\"<nameLN>\\"
\\"</nameLN>\\"
<nameLN>
</nameLN>
\\\">
\\\">
\\"<dupCountLN>\\"
\\"</dupCountLN>\\"
je.lck
rw
<dupCountLN>
</dupCountLN>
<<\\"A je.lckfile exists in \\">>
_jeUtilization
shared
single writer
_jeUtilization
\\\"/>
Cleaner duplicate key sequence file=0x
<<\\"The Environment directory \\">>
<din>
</din>
<<\\"usage: \\">>
<dupkey>
<<\\"\\">>
</dupkey>
<dupCountLN/>
DIN
Write after RunRecoveryException
Randomly generated for testing
<<\\"lsn \\">>
-f requires an argument
-h requires an argument
-s requires an argument
<<\\"-c: \\">>
-c requires an argument
<<\\"txnId = \\">>
-h is a required argument
-v requires -f
<DbLsn val=\\\"0x
0x
<<\\"DbLoad.load of \\">>
<<\\"Load start: \\">>
Must supply a database name if -l not supplied.
<<\\"DbLoad.load of \\">>
<<\\"Load end: \\">>
foreignKeyDeleteAction
<<\\"Invalid header parameter: \\">>
<<\\"Version \\">>
The SecondaryConfig argument is null.
\'
The following SecondaryConfig parameters for the\ncached Database do not match the parameters for the\nrequested Database:\n
<<\\" SecondaryKeyCreator\n\\">>
<<\\" SecondaryMultiKeyCreator\n\\">>
<<\\" ForeignKeyDelete\n\\">>
<<\\" ForeignKeyDeleteAction\n\\">>
<<\\" ForeignKeyNullifier\n\\">>
<<\\" ForeignMultiKeyNullifier\n\\">>
<<\\" ImmutableSecondaryKey\n\\">>
\\"DupRootRecover:\\"
\\"LNRedo:\\"
\\"LNUndo\\"
\\"INRecover:\\"
<<\\"No data to match key \\">>
\\"RootRecover:\\"
\\"INDelReplay:\\"
\\"INDupDelReplay:\\"
\\"RootDelete:\\"
<<\\"Key exists: \\">>
<<\\"loaded \\">>
No \\\"DATA=END\\\"
Usage: EnvironmentParams <samplePropertyFile>
####################################################\n# Example Berkeley DB, Java Edition property file\n# Each parameter is set to its default value\n####################################################\n\n
#
Corrupted file
Corrupted file
Recovery underway, found end of log
<<\\"Recovery checkpoint search, \\">>
Recovery w/no files.
<<\\"There are \\">>
<TreeLocation bin=\\\"
null
\\\" index=\\\"
\\\" lnKey=\\\"
\\\" childLsn=\\\"
\\\">
\\"  File    Size (KB)  % Used\n--------  ---------  ------\\"
recovery
RecoveryManager
recover
Couldn\'t recover
<<\\"Couldn\'t recover: \\">>
<<\\"Recovery finished: \\">>
<<\\"Recovery finished: \\">>
lastUsed=
\n
<<\\" TOTALS \\">>
<<\\"  \\">>
<<\\"     \\">>
numBottomInternalNodes=
\n
numInternalNodes=
\n
numDuplicateInternalNodes=
\n
numDuplicateBottomInternalNodes=
\n
\n
<<HASH:-870535562>>
\n
\n
\n
\n
\\"<mapLN>\\"
\\"</mapLN>\\"
<mapLN>
</mapLN>
\\\">
initialized
open
closed
invalid
<<\\"Can\'t go from environment state \\">>
\\"daemon\\"
\\"manual\\"
\\"critical\\"
readMapIns
\\\"/>
Evictor.addToQueue should never be called.
daemon
readNonMapIns
critical
Evictor: pass=
Evictor: pass=
<<\\"Found unfinished prepare record: id: \\">>
Evictor: pass=
undoLNs
<<\\"latches held = \\">>
<<\\" IN type=\\">>
redoLns
<<\\"Database \\">>
<<\\" lsnFromLog:\\">>
RecoveryManager
replaceOrInsert
lsnFromLog=
Trace list:
lsnFromLog=
RootRecover:
RootRecover:
DupRootRecover:
DupRootRecover:
<LockInfo locker=\\\"
\\\" type=\\\"
\\\"/>
<<\\" lock taken at: \\">>
INRecover:
INRecover:
INRecover:
LNRedo:
<<\\"Pass 1: \\">>
<<\\"Pass 2: \\">>
<<\\"End: \\">>
LNRedo:
LNRedo:
<<\\"processing file \\">>
<<\\".jdb  \\">>
<<\\"Already name mapped for dbId: \\">>
<<\\"Already saw dupSort entry for dbId: \\">>
LNUndo
LNUndo
db
DATA=END
<<\\"\\">>
<<\\"\\">>
<<\\"\\">>
<<\\"\\">>
<<\\"Recovery Pass \\">>
<<\\"Recovery Pass \\">>
<<\\" node=\\">>
<<\\" lsn=\\">>
<<\\" found=\\">>
<<\\" replaced=\\">>
<<\\" inserted=\\">>
<<\\" replacedLsn=\\">>
<<\\" abortLsn=\\">>
INDupDelReplay:
INDelReplay:
<<\\"last LSN = \\">>
RecoveryManager
last LSN=
<<\\"Attempt to \\">>
RootDelete:
\\"<ln>\\"
\\"</ln>\\"
<<\\"Error Key \\">>
UNKNOWN
<<\\"Error Data \\">>
UNKNOWN
<ln>
</ln>
<<\\"maxBytes parameter to Database.preload() was specified as \\">>
<data>
</data>
<database id=\\\"
\\\"
<<\\" btc=\\\"\\">>
\\\"
<<\\" dupc=\\\"\\">>
\\\"
/>
Btree
Duplicate
couldn\'t instantiate class comparator
<database>
\\\"/>
<btcf name=\\\"
\\\"/>
<dupcf name=\\\"
\\\"/>
</database>
<<\\"\\">>
<data>
</data>
<<\\"Exception while trying to load \\">>
<<\\"Exception while trying to load \\">>
\\\" isProvisional=\\\"true
\\\" prev=\\\"0x
<<\\"Cache percent is not a valid integer: \\">>
\\\">
</entry>
,
,
NEXT
PREV
NEXT_DUP
PREV_DUP
NEXT_NODUP
PREV_NODUP
All nodes should have been loaded
<lastFullLsn>
</lastFullLsn>
\\\"/>
READ
WRITE
RANGE_READ
RANGE_WRITE
RANGE_INSERT
NONE
RESTART
<
<<\\" exists = \\\"\\">>
\\\">
\\\"/>
Unexpected interrupt while waiting for fsync
<Transaction id=\\\"
\\\"
<<\\" name=\\\"\\">>
\\\"
>
<<\\"Transaction \\">>
\\"!\\\"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\"
!\\\"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~
false
true
SEVERE
false
<<\\"java { \\">>
Cleaner.addToQueue should never be called.
<<\\"CleanerRun \\">>
Cleaner
doClean
<<\\"\\">>
<<\\"CleanerRun \\">>
<<\\"CleanerRun \\">>
CleanLN:
CleanLN:
CleanLN:
CleanLN:
CleanLN:
CleanLN:
CleanLN:
CleanIN:
CleanIN:
CleanIN:
\\\"/>
r
rw
\\\">
>
Nested transactions are not supported yet.
<<\\"XA Transaction \\">>
copy.remaining=
